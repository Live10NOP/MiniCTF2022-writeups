Challenge name: 1984
Difficulty: Medium/Hard

Part 1 (Understanding the program):
First of all, this program makes heavy use of the heap. Understanding the glibc heap implementation is essential to understanding the intended exploit. The heap is used by programs to allocate dynamic memory. A brief summary of the challenge binary is as follows. This program allows the user to malloc chunks of size 0x50, free them, edit them, and display their contents. When exiting the program, a new thread is created and an input of max size 0x1000 is read into a buffer of size 0x10. The program is also compiled with PIE, NX, stack smashing protection, and partial RELRO.

Part 2 (the vulnerabilities):
It is clear that when we exit the program we get a buffer overflow vulnerability. This should allow us to modify the program's contol flow by overwriting the return address on the stack. However, there are currently 2 issues that prevent us from exploiting this overflow. First of all, we do not know the value of the canary, and overwriting it with an incorrect value will cause the program to abort before we can reach our modified return address. Secondly, even if we are able to gain control of the program's execution, we still have no idea where to go since we do not have an infoleak and aslr is turned on. So how do we get an infoleak?

Part 3.1 (exploiting the heap for an infoleak):
First we must note that the glibc library linked to this program is quite new, and it utilizes the tcache. Our goal is to somehow leak a libc address using the heap. One way this can be achieved is through the small/large/unsorted bins. These bins consist of free chunks connected by a doubly-linked list, utilizing fwd and bk pointers. If only 1 chunk exists these bins, its fwd and bk pointers should contain a pointer to the main arena. If we can somehow get access to a chunk that was in one of these bins, we can display either the fwd or bk pointer and get a leak. However, there is no way for us to malloc then free a chunk large enough to be put into one of these bins. We are only allowed to create chunks of size 0x50 and free them. Even if we free enough chunks to fill the tcache bin, the remaining freed chunks will go into the corresponding fastbin. In addition, the chunks in the fastbin do not contain pointers to libc, so what the heck do we do now???

Part 3.2 (the behaviour of scanf()):
So turns out, after looking into the implementation of scanf() for a bit, we find that if we give scanf an input that is of a sufficiently large size, it will allocate a chunk on the heap to store the input, parse the input according to the format specifier, and then free that chunk. So for example, if we give an input of 0x500 zeros to scanf("%d", buffer), a chunk of size 0x500 will be malloced then freed before the function returns. So is this how we get a chunk in the unsorted bin? Well actually no, because unfortunately that massive chunk will get consolodated with the top chunk when it is freed. Ok, so this behaviour is useless then? Well not quite. If we take a closer look at the behavior of the glibc allocator when allocating large chunks, we find a function called malloc_consolodate() which gets called. This function tries to consolodate adjacent free chunks on the heap together to create 1 larger freed chunk. Freed chunks in the tcache will not be affected, since they are not technically "freed", just cached. However, freed chunks anywhere else will be affected, including those in the fastbins. We can abuse this behaviour of the glibc heap allocator to force a chunk into the smallbin by consolodating adjacent freed chunks in the fastbin. This will allow us to leak a pointer to the main arena once we allocate a chunk from the smallbin and display its contents.

Part 4 (threads and the stack canary):
Everytime before a function returns, the value of the canary on the stack is checked against its original value. However, how does the program know what the original canary value is? Turns out, this value is stored at an offset from an address contained in the fs register. In single threaded programs, this data is contained in the .tls section. However by default in multithreaded programs, important data, such as the canary value, is copied from the main thread and stored in a special struct. This struct, containing thread local data, resides somewhere towards the bottom of the new thread's stack. In the new thread, the value of the fs register points to the address of this struct. Luckily for us, our buffer overflow allows us to overwrite the values in this struct, and as a result, change the canary value to whatever we want. As long as the canary value in our current stack frame is the same as the value of the canary that we overwrote, stack smashing protection will not get triggered and we can get control over the new threads execution.


Rough outline of the exploit:

Step 1: (leaking libc addr)
-Fill up 0x50 tcache bin
-Fill 0x50 fastbin
-Malloc a chunk of size 0x500 by giving scanf an input of 0*0x500
-Mallocing such a large chunk will lead to malloc_consolodate() getting called, which will consolodate the chunks in the fastbin and put it into the smallbin.
-Malloc the chunks in the tcache
-Malloc 1 more chunk to get a chunk from the smallbin
-Diplay the contents of that chunk to get a libc address leak using the bk pointer

Step 2: (exploiting the overflow)
-When a new thread is created, a struct containing thread local data is created at the bottom of the stack, and is pointed to by the fs register.
-This thread local data contains the value that the stack canary is checked against.
-The overflow allows us to overwrite the value of the canary to whatever we want, allowing us to construct and execute a ropchain consisting of gadgets from libc, and get a shell!!!
